2008-10-21

I went back to work on my Ruby based board game domain language for a bit.  A lot of it was getting back into the meta-programming tricks I've been using, which I haven't really talked about yet, and probably should before I forget.

I started the project once and got some things mostly working, but things started to get messy when it got actually running the game.  The notation was also still very... programmy.  You have to expect that a bit when using an embedded language - a legal program in the host language, in contrast to an external language, wherein one enters the interpreter or compiler tarpit I was dipping my toes in above.  However ruby offers a quite lax and varied syntax (or enough rope to hang yourself and the rest of the neighborhood, take your pick) and I decided the end result would be much better if I used more of it.

So, I started over, this time writing an acceptable semi-structured form first, which I am slowly going through and converting in a Ruby-acceptable syntax, writing the necessary back end code as I go.  Making a text that read well in two language takes a few ugly/beautiful hacks, and, though this may be a bit premature, here is a survey of some of them.

method_missing

Ruby is object oriented, where object methods can be thought of as message sends.  In fact, you can just use object.send if you have a string you'd like to use as a method name.  If that string isn't method, you (or rather, the object) gets a chance to do something creative with it before an not found exception is generated.  Forward to another object, create a property, look it up in hash table, or whatever suits your fancy.  Another fun trick is mixing a module I call Prototype into my classes, causing them to emit a message for missing methods, but not halt the program.

Class.new()

This is one of those things where one either says "Huh?"/"Oh my god"/"So?"  I was most recently in middle category.  In a sense I should have known this, having read <a href="http://isbn.nu/9780262111584">The Art of the Metaobject Protocol</a>, however I didn't really get into it enough to fully understand what was going.  It might have moved from the first to the second category, however.  In my case, I wanted to create a class for each resource type in the game, which might then be instanced for each player.  Class.new() is the object creation method of the class of classes; it returns a runtime instance of a class.  You can hide this in an api, add properties and methods to the new class, and then use it just like normal.

instance_eval

One of the more popular and dangerous language techniques, this can run a string or block as if belongs to the object.  This raises a lot of issues about scoping and especially instance variables, but it can enable some very nice notation when used carefully.  I'm not sure if my case should be called careful: I'm not flinging them around willy-nilly, but I am using a <a href="http://www.artima.com/rubycs/articles/ruby_as_dsl.html">trick</a> recommended by my dear friend Google to run my entire domain language file in the context of the 'game object'.

2008-11-13, 2008-11-15

I did lot of work on the board game domain specific language during the last weekend, and on into the next week.  I dug myself quite a hole by getting into the choice question, and just couldn't pull myself away.  Since then, I've had to deal with little things like food and a noisy furnace blower, and writing about it got pushed back and back.  Stuff found while looking up links didn't help either ;^)

Adding Cards

GSL now does cards.  My development example is <a href="http://boardgamegeek.com/game/2476">Industrial Waste</a>.  I decided to do the initial work in a published game that is known to work.  Industrial Waste has the 'designer' feel while being fairly clean and not too complicated.  For simple things, the language can be quite nice.

<pre class="ruby code">
card :order do
  must_have {co_workers >= rationalization}
  pay materials_required.value, :raw_materials
  must_gain waste_reduction.value, :waste_disposal
  gain growth.value, :money
end
</pre>

There are still warts of course, such as the .value on resources, and the difference between a resource and it's :symbol.

If it Quacks Like Proc...

I developed a number of systems around processing cards, where cards have associated actions. Then I found I sometimes needed to make choices based on other pieces of code that weren't cards - usually they were procs, Ruby's psuedo-closure objects.  To work around this, I make cards support to_proc.  to_proc is an identity function on proc objects, and the choice system will operate on anything that implements to_proc.

Department of HomeDeck Security

In the course of playing with several fundamental questions - such as if a card is removed from a hand when it's chosen or when it's used - I found cards were disappearing or being duplicated (sometimes infinitely).  The current version has each card register it's location (an advantage of making them objects), as well as check for duplicates or oversized stacks.  Currently discard piles are grafted onto the main card set resource, but long term I think they should become their own resources, so you can have many-one and one-many relationships.

I may also want to investigate unit tests sometimes.

In Context

One particular problem was the Bribery card, which can only be played during an accident.  I could have perhaps made Bribery unplayable and had it discard during accidents, but that doesn't cleanly account for the cost of the playing the card.  I created a context system - automatic for defined functions such as game phases and accidents, no less - that worked out quite nicely.  The game now has "only_during :accident" and "lose(1, :growth) unless use(:bribery, :held_cards)"

Averting Tragedy in the Commons

In some cases, resources are shared rather than assigned to players.  When writing game rules, the name is usually sufficient to separate them and one doesn't want to write something different (common_gain, player_gain, etc.) for each case.  The game and player classes share a Resource_User module which has common definitions for most of the resource handling methods.

The including class can name a delegate for resources it doesn't recognize, which is presumably another Resource_User.  Most of the actual work ends up getting handled by the resource itself, so it's just a matter of sending the appropriate methods on.  Of course, I wasn't too keen on writing this out for every method, especially given the user-forwarding mentioned above.  So I implemented a class method that defines them given only the name, in a manner similar to attr_accessor and company.

Sufficiently Advanced Technology

One of the fascinating things about getting into a project like this with heavy meta-programming is that I'm slowly discovering the kind of tricks that make projects like Rails famous for having hard to understand 'magic' in the framework.  I still don't have a real good intuition for Ruby's object model however.  Or rather, I have a fair intuition in the sense that I can often place something where it needs to be, but I couldn't necessarily draw a diagram of the class system, even though I've seen one a couple of them.

Dangerous Speculations

At some point, it was necessary to get away from random choice.  For one thing, the computer players were sometimes choosing illegal actions.  Complicating this are some very high ambitions: I don't want there to be any game-specific AI code, except perhaps if one want's to try out different strategies against each other, and even then easy things should be easy.

My first attempt at something-better-than-random is the Speculate class, a sort of psuedo-player that can execute actions in a different context where it can check most resource levels and such.  Eventually it ended up doing enough itself that I pulled some of the player routines into a common module that can be shared with the speculator.

Speculation has been successful in the sense that it can check for illegal plays, however there isn't yet any provision for discrimination beyond legal/illegal.  I've also run into a bit of an issue: I've implemented the part of the game that charges maintenance costs, which means players can run out of money without having any choice in the matter.  The board game has rule for loans, but it defines them by an at-any-time action.  I'd like to keep the language code as similar to the rules as possible, and I haven't found a good place to hook this in yet, especially in the presence of speculation.  I'm starting to think that I'm going to need a full copy-on-write resource system with the speculator executing more of the actions and figuring out a score change.

Beyond Scripting

In the course of all this, the framework file line count started getting into the high triple digits and getting generally unwieldy.  The only other Ruby projects I've done were simple scripting that fight nicely in one file, and Rails, which has a very regimented structure.  A short search found <a href="http://blog.jayfields.com/2006/10/ruby-project-tree.html">Jay Fields thoughts on ruby project structure</a>.  I actually didn't follow most of his advice - just the use of the lib directory, so far.  I was also looking through <a href="http://github.com/gilesbowkett/archaeopteryx/wikis/home">Archaeopteryx</a>, which I had downloaded recently out of curiosity on it's heavy use of lambdas; the project structure basically agreed with the advice given.

After getting things split up, I also wrapped most of it up in module.

I'll Raise You Two Exception Mechanisms

When it came time actually start catching my insufficient resource exceptions, I found out I'd been doing it wrong.  Ruby has not one but two exception mechanisms, and I'd been mixing them.  raise gets rescued, throw gets caught.

An Instance of Difficulty

I ran into one hitch with my crazy metaprogramming.  I've been using instance_eval to set a default receiver for methods/messages.  This worked pretty well for a long time, since I was mostly defining game phases, cards, and other things that don't take arguments.  Then, I actually hit a case where I wanted to instance_eval with arguments.  It doesn't do that.

It turns out this is a known problem; there is an instance_exec in 1.9, but that is still under development.  Fortunately, you can <a href="http://www.jroller.com/abstractScope/entry/passing_parameters_to_an_instance">implement instance_exec in 1.8</a> with some high concept metaprogramming.

2008-12-30

One of the things I did today was refactor a small Ruby helper module.  It was monkey-patching Object and Class, and it now works as a optional module for case-by-case use.  Figuring it out involved a lot of trial and error where where to stick things in Ruby's object system.

The module does class variables of the kind that are equally visible from both the class and it's instances.  Ruby has these (@@var), but they don't work the way I want.  Once one of Ruby's @@vars gets attached to a class, anything related will end up with that copy of the variable rather than creating a new one, whether you want it or not.  I had a situation where a module needed add different variables into each class it extended - doing it Ruby's way ended up with one common variable in the shared module.

The resolution, of sorts, was to make method with the same name for both class and object, but with slightly different definitions.  The class version points to itself, and the object version points to it's class.  Further, if you don't like the class that get's chosen, just redefine 'cv'.

The first version of this monkey-patched Class and Object.  It's messy, but after figuring out the hard way, I can kind of understand why I might have tried and given up on doing a proper module earlier ;^)

I recently grabbed the file for another project.  I've also been experimenting with RSpec, so it seemed like a good opportunity to spec out the desired results and then refactor.  The testing part worked out fairly well - once things got built up, I could get an overview of which parts broke as I tried wiggling things until they worked ;^)

Basic function was pretty straightforward - the tests passed and I thought I was done.  Then went back to the application and realized my tests weren't ver good ;^)  The original application, if you recall, used class variables in module to be used later.  My refactored ClassVars didn't work this situation.

As best I can make of it, you 'include' to add the module's routines as if they were entered as straight text (sort of).  You 'extend' to modify the superclass, making the methods available for use in the class definition, for one.

Since my application module will ultimately be used to extend, I have to include in the module itself.  This mostly works, except that instances of the extended application classes don't have 'cv'.

What I ended up doing was have the 'included' callback 'extend' the target class with the 'included'/'extended' triggers.  The SuperClass below was called Triggers at first.

2009-01-18

Testing Under the World Tree

I've been hammering on the board game DSL for a few weeks now.  Most of the time was spent retroactively adding tests, however, so it felt like I wasn't going anywhere ;^)

I've been staring up at a potentially nasty change to the way game state is handled, and wondering how to work out all the ramifications.  From following the Ruby conference videos and other like things, I've picked up that test driven development is rather big in at least a section of the Ruby community.  I tried out <a href="http://rspec.info/">RSpec</a> on a different project over the holiday.  That project had slightly more testable nature - data containers, mostly, and it went fairly well, although for all I've done with it so far, it's debatable whether it was a win or not.

GSL, on the other hand, is longer lived project, which has gotten fairly large.  I'm relatively satisfied with the language syntax, and it's complicated enough beast that debugging is becoming an impediment to progress.  Only problem is, writing tests isn't all that much, and I've got solid testing in front of me.  It really kind of felt like I was spinning my wheels, with only the promises of the testing zealots to convince me that this was better in the long term.

It's only recently that I've actually gotten to turning the world upside down.  Obviously, the application will usually break at the same time the tests do.  The tests have been fairly good at immediately narrowing the problem down, rather than going and enabling prints until you back the problem into a corner.

Amnesia

GSL has, from to time to time, to consider whether an action is legal, or wise in the case of computer players.  (Actually, there are only computer players at the moment.)  This has been done with a Speculate class that shares a common module with Player.  It forwards resource checks and ignores most everything else.  Unfortunately, since it doesn't change anything, it also impossible to properly evaluate multiple-step actions or consider whether a course of action made the player's position better or worse.

Axis Mundi

My Grand Unified Solution to this problem is to put all game data in a versioned store, which can be checkpointed or taken off into speculative territory at will.  It might be owing in part to an acute case of Javascript infection - world states are stored in sparse hash tables which roll down to a parent in case of missing keys.  I guess anything that gets called the <a href="http://steve-yegge.blogspot.com/2008/10/universal-design-pattern.html">Universal Design Pattern</a> can't be all that wrong.

A side benefit of the structure is that I can theoretically checkpoint a version every turn or so and have a complete game history.

Hanging Loosely From the World Tree

For the time being, this construct is called <a href="http://bitbucket.org/JustinLove/gsl/src/tip/lib/world.rb">World</a>.  Due to the potential tree like nature of states, I've considered changing the module's name to Yggdrasil, but haven't yet, in part due to a lack of good names for the sub modules.  It was kind of impressive how much I got in a small amount of code, but of course it's ballooned with little convenience features.  There are four sub modules: State, which wraps a hash table of values, View, which keeps a pointer to the 'current' state, Passport, which streamlines prepending each citizen's id to it's values, and Citizen, a module that for objects that will use the store, offering reader/writer/accessor methods and like.

Going Nowhere Fast

I started work on the world module after fleshing out the rest of the tests.  I actually worked in a more test driven method.  Testing works out much better for new code - the alternating breaks up the monotonous parts.  I've discovered a danger of TDD however.  It's very easy to implement features that completely fail the You Ain't Gonna Need It principle.  For instance, an easy and obvious thing to do was implement begin/commit/abort style transactions.  Easy, yes.  But useful to my application?  Not currently.  I actually found myself a little directionless looking for the proper abstractions.  I only had tests, not an actual application to define the desired interface.  Test can help you implement things, but they don't offer much help in design.

The World is Flat

One reason an existing transaction module wouldn't work is that the whole game has change state at once - if a speculative action doesn't pan out, everything has to be undone, including response by other players.  I didn't really care to get into the complexity of rebuilding the spines of trees when a leaf value changed, so that means that the store is a flat namespace, managed by prepending a unique object id to each key.  This ends up having a lot of far reaching consequences.

The World is Rather Bumpy

By far the biggest problem is the Set resources that hold things like decks and hands of cards.  Ruby doesn't make things easy here.  Most things are passed around by reference to an object.  The object can be changed indiscriminately without affecting the references in the least.  This means that naive way of storing sets will usually change prior states rather than updating the current one.

Turning the World On it's Head?

One solution to this problem is turn the resources upside down: store the location of each object and create sets by searching the store for the right location.  Since cards have to have properties, they are already objects, and in fact already have an 'in' property from card movement debugging.  I'm a little leery of the search efficiency, however.  A larger problem is the fact that I'd really like sets to be able to handle arbitrary objects, including atoms that can't have properties attached.

Ice World

What I have for the moment is an ice-world that freezes(makes immutable) everything that goes into it.  It's not recursive, however, so arrays and things inside the world objects can still be modified.  But, this gets the runtime system to cry bloody murder in most situations where you might be changing the past instead of the present, and allowed me to make appropriate adjustments.  In a couple of cases I had to version class variables I would have otherwise left alone, because the class was getting frozen.  It's probably safer having them versioned, anyway.

