2008-10-21

I went back to work on my Ruby based board game domain language for a bit.  A lot of it was getting back into the meta-programming tricks I've been using, which I haven't really talked about yet, and probably should before I forget.

I started the project once and got some things mostly working, but things started to get messy when it got actually running the game.  The notation was also still very... programmy.  You have to expect that a bit when using an embedded language - a legal program in the host language, in contrast to an external language, wherein one enters the interpreter or compiler tarpit I was dipping my toes in above.  However ruby offers a quite lax and varied syntax (or enough rope to hang yourself and the rest of the neighborhood, take your pick) and I decided the end result would be much better if I used more of it.

So, I started over, this time writing an acceptable semi-structured form first, which I am slowly going through and converting in a Ruby-acceptable syntax, writing the necessary back end code as I go.  Making a text that read well in two language takes a few ugly/beautiful hacks, and, though this may be a bit premature, here is a survey of some of them.

method_missing

Ruby is object oriented, where object methods can be thought of as message sends.  In fact, you can just use object.send if you have a string you'd like to use as a method name.  If that string isn't method, you (or rather, the object) gets a chance to do something creative with it before an not found exception is generated.  Forward to another object, create a property, look it up in hash table, or whatever suits your fancy.  Another fun trick is mixing a module I call Prototype into my classes, causing them to emit a message for missing methods, but not halt the program.

Class.new()

This is one of those things where one either says "Huh?"/"Oh my god"/"So?"  I was most recently in middle category.  In a sense I should have known this, having read <a href="http://isbn.nu/9780262111584">The Art of the Metaobject Protocol</a>, however I didn't really get into it enough to fully understand what was going.  It might have moved from the first to the second category, however.  In my case, I wanted to create a class for each resource type in the game, which might then be instanced for each player.  Class.new() is the object creation method of the class of classes; it returns a runtime instance of a class.  You can hide this in an api, add properties and methods to the new class, and then use it just like normal.

instance_eval

One of the more popular and dangerous language techniques, this can run a string or block as if belongs to the object.  This raises a lot of issues about scoping and especially instance variables, but it can enable some very nice notation when used carefully.  I'm not sure if my case should be called careful: I'm not flinging them around willy-nilly, but I am using a <a href="http://www.artima.com/rubycs/articles/ruby_as_dsl.html">trick</a> recommended by my dear friend Google to run my entire domain language file in the context of the 'game object'.

2008-11-13, 2008-11-15

I did lot of work on the board game domain specific language during the last weekend, and on into the next week.  I dug myself quite a hole by getting into the choice question, and just couldn't pull myself away.  Since then, I've had to deal with little things like food and a noisy furnace blower, and writing about it got pushed back and back.  Stuff found while looking up links didn't help either ;^)

Adding Cards

GSL now does cards.  My development example is <a href="http://boardgamegeek.com/game/2476">Industrial Waste</a>.  I decided to do the initial work in a published game that is known to work.  Industrial Waste has the 'designer' feel while being fairly clean and not too complicated.  For simple things, the language can be quite nice.

<pre class="ruby code">
card :order do
  must_have {co_workers >= rationalization}
  pay materials_required.value, :raw_materials
  must_gain waste_reduction.value, :waste_disposal
  gain growth.value, :money
end
</pre>

There are still warts of course, such as the .value on resources, and the difference between a resource and it's :symbol.

If it Quacks Like Proc...

I developed a number of systems around processing cards, where cards have associated actions. Then I found I sometimes needed to make choices based on other pieces of code that weren't cards - usually they were procs, Ruby's psuedo-closure objects.  To work around this, I make cards support to_proc.  to_proc is an identity function on proc objects, and the choice system will operate on anything that implements to_proc.

Department of HomeDeck Security

In the course of playing with several fundamental questions - such as if a card is removed from a hand when it's chosen or when it's used - I found cards were disappearing or being duplicated (sometimes infinitely).  The current version has each card register it's location (an advantage of making them objects), as well as check for duplicates or oversized stacks.  Currently discard piles are grafted onto the main card set resource, but long term I think they should become their own resources, so you can have many-one and one-many relationships.

I may also want to investigate unit tests sometimes.

In Context

One particular problem was the Bribery card, which can only be played during an accident.  I could have perhaps made Bribery unplayable and had it discard during accidents, but that doesn't cleanly account for the cost of the playing the card.  I created a context system - automatic for defined functions such as game phases and accidents, no less - that worked out quite nicely.  The game now has "only_during :accident" and "lose(1, :growth) unless use(:bribery, :held_cards)"

Averting Tragedy in the Commons

In some cases, resources are shared rather than assigned to players.  When writing game rules, the name is usually sufficient to separate them and one doesn't want to write something different (common_gain, player_gain, etc.) for each case.  The game and player classes share a Resource_User module which has common definitions for most of the resource handling methods.

The including class can name a delegate for resources it doesn't recognize, which is presumably another Resource_User.  Most of the actual work ends up getting handled by the resource itself, so it's just a matter of sending the appropriate methods on.  Of course, I wasn't too keen on writing this out for every method, especially given the user-forwarding mentioned above.  So I implemented a class method that defines them given only the name, in a manner similar to attr_accessor and company.

Sufficiently Advanced Technology

One of the fascinating things about getting into a project like this with heavy meta-programming is that I'm slowly discovering the kind of tricks that make projects like Rails famous for having hard to understand 'magic' in the framework.  I still don't have a real good intuition for Ruby's object model however.  Or rather, I have a fair intuition in the sense that I can often place something where it needs to be, but I couldn't necessarily draw a diagram of the class system, even though I've seen one a couple of them.

Dangerous Speculations

At some point, it was necessary to get away from random choice.  For one thing, the computer players were sometimes choosing illegal actions.  Complicating this are some very high ambitions: I don't want there to be any game-specific AI code, except perhaps if one want's to try out different strategies against each other, and even then easy things should be easy.

My first attempt at something-better-than-random is the Speculate class, a sort of psuedo-player that can execute actions in a different context where it can check most resource levels and such.  Eventually it ended up doing enough itself that I pulled some of the player routines into a common module that can be shared with the speculator.

Speculation has been successful in the sense that it can check for illegal plays, however there isn't yet any provision for discrimination beyond legal/illegal.  I've also run into a bit of an issue: I've implemented the part of the game that charges maintenance costs, which means players can run out of money without having any choice in the matter.  The board game has rule for loans, but it defines them by an at-any-time action.  I'd like to keep the language code as similar to the rules as possible, and I haven't found a good place to hook this in yet, especially in the presence of speculation.  I'm starting to think that I'm going to need a full copy-on-write resource system with the speculator executing more of the actions and figuring out a score change.

Beyond Scripting

In the course of all this, the framework file line count started getting into the high triple digits and getting generally unwieldy.  The only other Ruby projects I've done were simple scripting that fight nicely in one file, and Rails, which has a very regimented structure.  A short search found <a href="http://blog.jayfields.com/2006/10/ruby-project-tree.html">Jay Fields thoughts on ruby project structure</a>.  I actually didn't follow most of his advice - just the use of the lib directory, so far.  I was also looking through <a href="http://github.com/gilesbowkett/archaeopteryx/wikis/home">Archaeopteryx</a>, which I had downloaded recently out of curiosity on it's heavy use of lambdas; the project structure basically agreed with the advice given.

After getting things split up, I also wrapped most of it up in module.

I'll Raise You Two Exception Mechanisms

When it came time actually start catching my insufficient resource exceptions, I found out I'd been doing it wrong.  Ruby has not one but two exception mechanisms, and I'd been mixing them.  raise gets rescued, throw gets caught.

An Instance of Difficulty

I ran into one hitch with my crazy metaprogramming.  I've been using instance_eval to set a default receiver for methods/messages.  This worked pretty well for a long time, since I was mostly defining game phases, cards, and other things that don't take arguments.  Then, I actually hit a case where I wanted to instance_eval with arguments.  It doesn't do that.

It turns out this is a known problem; there is an instance_exec in 1.9, but that is still under development.  Fortunately, you can <a href="http://www.jroller.com/abstractScope/entry/passing_parameters_to_an_instance">implement instance_exec in 1.8</a> with some high concept metaprogramming.

2008-12-30

One of the things I did today was refactor a small Ruby helper module.  It was monkey-patching Object and Class, and it now works as a optional module for case-by-case use.  Figuring it out involved a lot of trial and error where where to stick things in Ruby's object system.

The module does class variables of the kind that are equally visible from both the class and it's instances.  Ruby has these (@@var), but they don't work the way I want.  Once one of Ruby's @@vars gets attached to a class, anything related will end up with that copy of the variable rather than creating a new one, whether you want it or not.  I had a situation where a module needed add different variables into each class it extended - doing it Ruby's way ended up with one common variable in the shared module.

The resolution, of sorts, was to make method with the same name for both class and object, but with slightly different definitions.  The class version points to itself, and the object version points to it's class.  Further, if you don't like the class that get's chosen, just redefine 'cv'.

The first version of this monkey-patched Class and Object.  It's messy, but after figuring out the hard way, I can kind of understand why I might have tried and given up on doing a proper module earlier ;^)

I recently grabbed the file for another project.  I've also been experimenting with RSpec, so it seemed like a good opportunity to spec out the desired results and then refactor.  The testing part worked out fairly well - once things got built up, I could get an overview of which parts broke as I tried wiggling things until they worked ;^)

Basic function was pretty straightforward - the tests passed and I thought I was done.  Then went back to the application and realized my tests weren't ver good ;^)  The original application, if you recall, used class variables in module to be used later.  My refactored ClassVars didn't work this situation.

As best I can make of it, you 'include' to add the module's routines as if they were entered as straight text (sort of).  You 'extend' to modify the superclass, making the methods available for use in the class definition, for one.

Since my application module will ultimately be used to extend, I have to include in the module itself.  This mostly works, except that instances of the extended application classes don't have 'cv'.

What I ended up doing was have the 'included' callback 'extend' the target class with the 'included'/'extended' triggers.  The SuperClass below was called Triggers at first.

2009-01-18

Testing Under the World Tree

I've been hammering on the board game DSL for a few weeks now.  Most of the time was spent retroactively adding tests, however, so it felt like I wasn't going anywhere ;^)

I've been staring up at a potentially nasty change to the way game state is handled, and wondering how to work out all the ramifications.  From following the Ruby conference videos and other like things, I've picked up that test driven development is rather big in at least a section of the Ruby community.  I tried out <a href="http://rspec.info/">RSpec</a> on a different project over the holiday.  That project had slightly more testable nature - data containers, mostly, and it went fairly well, although for all I've done with it so far, it's debatable whether it was a win or not.

GSL, on the other hand, is longer lived project, which has gotten fairly large.  I'm relatively satisfied with the language syntax, and it's complicated enough beast that debugging is becoming an impediment to progress.  Only problem is, writing tests isn't all that much, and I've got solid testing in front of me.  It really kind of felt like I was spinning my wheels, with only the promises of the testing zealots to convince me that this was better in the long term.

It's only recently that I've actually gotten to turning the world upside down.  Obviously, the application will usually break at the same time the tests do.  The tests have been fairly good at immediately narrowing the problem down, rather than going and enabling prints until you back the problem into a corner.

Amnesia

GSL has, from to time to time, to consider whether an action is legal, or wise in the case of computer players.  (Actually, there are only computer players at the moment.)  This has been done with a Speculate class that shares a common module with Player.  It forwards resource checks and ignores most everything else.  Unfortunately, since it doesn't change anything, it also impossible to properly evaluate multiple-step actions or consider whether a course of action made the player's position better or worse.

Axis Mundi

My Grand Unified Solution to this problem is to put all game data in a versioned store, which can be checkpointed or taken off into speculative territory at will.  It might be owing in part to an acute case of Javascript infection - world states are stored in sparse hash tables which roll down to a parent in case of missing keys.  I guess anything that gets called the <a href="http://steve-yegge.blogspot.com/2008/10/universal-design-pattern.html">Universal Design Pattern</a> can't be all that wrong.

A side benefit of the structure is that I can theoretically checkpoint a version every turn or so and have a complete game history.

Hanging Loosely From the World Tree

For the time being, this construct is called <a href="http://bitbucket.org/JustinLove/gsl/src/tip/lib/world.rb">World</a>.  Due to the potential tree like nature of states, I've considered changing the module's name to Yggdrasil, but haven't yet, in part due to a lack of good names for the sub modules.  It was kind of impressive how much I got in a small amount of code, but of course it's ballooned with little convenience features.  There are four sub modules: State, which wraps a hash table of values, View, which keeps a pointer to the 'current' state, Passport, which streamlines prepending each citizen's id to it's values, and Citizen, a module that for objects that will use the store, offering reader/writer/accessor methods and like.

Going Nowhere Fast

I started work on the world module after fleshing out the rest of the tests.  I actually worked in a more test driven method.  Testing works out much better for new code - the alternating breaks up the monotonous parts.  I've discovered a danger of TDD however.  It's very easy to implement features that completely fail the You Ain't Gonna Need It principle.  For instance, an easy and obvious thing to do was implement begin/commit/abort style transactions.  Easy, yes.  But useful to my application?  Not currently.  I actually found myself a little directionless looking for the proper abstractions.  I only had tests, not an actual application to define the desired interface.  Test can help you implement things, but they don't offer much help in design.

The World is Flat

One reason an existing transaction module wouldn't work is that the whole game has change state at once - if a speculative action doesn't pan out, everything has to be undone, including response by other players.  I didn't really care to get into the complexity of rebuilding the spines of trees when a leaf value changed, so that means that the store is a flat namespace, managed by prepending a unique object id to each key.  This ends up having a lot of far reaching consequences.

The World is Rather Bumpy

By far the biggest problem is the Set resources that hold things like decks and hands of cards.  Ruby doesn't make things easy here.  Most things are passed around by reference to an object.  The object can be changed indiscriminately without affecting the references in the least.  This means that naive way of storing sets will usually change prior states rather than updating the current one.

Turning the World On it's Head?

One solution to this problem is turn the resources upside down: store the location of each object and create sets by searching the store for the right location.  Since cards have to have properties, they are already objects, and in fact already have an 'in' property from card movement debugging.  I'm a little leery of the search efficiency, however.  A larger problem is the fact that I'd really like sets to be able to handle arbitrary objects, including atoms that can't have properties attached.

Ice World

What I have for the moment is an ice-world that freezes(makes immutable) everything that goes into it.  It's not recursive, however, so arrays and things inside the world objects can still be modified.  But, this gets the runtime system to cry bloody murder in most situations where you might be changing the past instead of the present, and allowed me to make appropriate adjustments.  In a couple of cases I had to version class variables I would have otherwise left alone, because the class was getting frozen.  It's probably safer having them versioned, anyway.

2009-01-29

Evolution, Futures, and Pacing

World Invasion

I got the versioned worlds system loosely integrated to the gsl framework in the previous iteration.  The work of the last weekend or so has been slowly refactoring GSL to take advantage of the new possibilities.
<lj-cut>
Forking Reality

For instance, the old system would be constantly recalculating speculations in order to rate them, check legality, and finally execute.  The possibility now open to me is to calculate the new state, and then keep it around until I've decided what to do with it.  At that time, execution is just updating some pointers.

Explosion and Extinction

After getting the hooks for branching in place, the trick was interfacing it to everything else.  As I started refactoring the choice routine and it's various helpers, there was sort of a cambrian explosion of methods as new paths appeared and the old ones were still in use.  Followed, of course, by the slow pruning of the unfit specimens

Evolution in Action

As the future-state concept started bubble it's way through the various abstraction layers, I ran into a small problem.  Previously, I would take in some proposed action, run it through a rating function, and return that.  Later, the game code might speculate again to see if it was a good or bad idea, and yet again to see if it was a legal move.  One of my goals was to reduce that to one calculation that could be reviewed as necessary.  That left me in the position of having to return multiple items, however, such as a state-and-rating or a state-and-action.

Now, you can certainly return multiple values in Ruby (really arrays, with some syntax sugar), but some places really only needed one of the values, and the destructuring seemed a dubious overhead to impose.  I started out making up a hash of properties, but this didn't last very long before being upgraded to a full object.  My old, stripped down speculator, hanging on to it's independent existence for hysterical raisins, was converted into a speculation. 

One of Those Awful/Wonderful Things

As I converted from hash to object, I faced the prospect changing all the references from hash-syntax to message syntax.  However, Ruby can define the indexing operator "[]".  In fact, it can alias the indexing operator to the message send method:

alias_method :[], :__send__

And now you can say object[:property] where you would have said object.property  I've since abandoned this clever hack, since I renamed all the properties anyway.

Four <a href="http://www.kipling.org.uk/poems_serving.htm">Honest Serving Men</a>

At some point, I realized that the speculation object existed to answer questions about the future.  In fact it's properties - the object (player) speculating, the action, some context information for debugging, and an action  modifier, mapped quite nicely onto who, what, why, and how.  'When' is the speculation itself, but 'where' has no obvious mapping as of yet.

The Future is Nil

There existed one annoying corner case: sometimes, a choice would be requested from a list of no possibilities.  The choose method has to return something, and up until recently it returned nil, Ruby's null object.  However, I found that the process of capturing the speculation into a variable and testing it before proceeding really through of the chain-of-methods style.  So I implemented a <a href="http://en.wikipedia.org/wiki/Null_Object_pattern">null object pattern</a> that could suitable respond to anything necessary.

How to Break Your AI by Doing Things Right

One of the places where I was recalculating speculations was in the card evaluation stage.  Having chosen a card, the computer players have to decide whether to play it, save it, or discard it.  This was one place where I wanted to get it only calculating once.  The flow of the DSL, however, strongly suggested that the card should be getting handled here, the speculations are an implementation detail.

Finally I realized that was doing things wrong from the beginning: by asking whether a card was good or bad I was encoding a single, definite, strategy into the rules.  The solution was rewrite "play, save, or discard" in terms of the choice method, and let it choose the best one.

What You, Stupid?

The only problem is that the current computer players, as such, are dirt simple stupid.  They're degree of discretion is limited to 'legal is better than illegal'  Unfortunately, with the new system players picked up a troubling tendency to an action that couldn't be completed and didn't advance the game-end condition.  So the game looped.  The temporary solution to this is to assign random ratings to legal moves, so that it doesn't get stuck in a loop.

With that in place, I polished up some other places where a little too much strategy had been written in to keep the dumb-as-dirt players moving forward.  (It can still lead to some... er... <em>suboptimal</em> moves, however.)

Class Action

Another instance of evolution in er, action, was the actions.  I had aliased Action to lambda to make a nicer language syntax for multi-step operations.  One of the problems I ran into is that, while a card might have a name, an action/lambda/proc doesn't, so it's often hard to follow what's going on, and this problem became more pronounced when I started using the choice method more.  So I derived an action class from Proc, with the sole addition that it takes a name in it's constructor.

Cut off at the Pass

Actions and speculations used to return Acted or Passed so that things like each_player_until_pass could tell what's up.  This became a bit difficult as things started returning speculations instead of booleans.  So I had to implement a passed flag with a language syntax of simply 'pass', which is less intrusive than always having to remember to return something.  However, I realized just when writing now that the passed flag needs to be a world-state variable.

Twice as Nice

Another piece of surface syntax I've cleaned up is 'use twice'.  This was a helper method from Industrial Waste's Advisor action, which will double the effect of most cards.  Unfortunately, the old method was to use an Action (lambda, proc) which has to be executed with use_twice.call (or [], but a wart is a wart)  In the course of working over the action execution system, I figured out that the only thing preventing it from being run through the 'use' method is the fact that it can't be discarded.  So just make discard ignore things that can't discarded, and we have "twice = action{...}; use twice"

Returns and Lambdas and Blocks (oh my)

However, in all may experiments, I ran across some very unusual behavior.  After some investigation, I finally tracked down that 'LocalJumpError' indicated that a block (an implicit baby-lambda that can be passed to any method) with return would <strong>return from it's parent method, not itself</strong>.  The actual lambda construct is unique in that it can actually have returns, but it requires some extra syntax.  Of course, the last statement of a method is an implicit return value, but sometimes the return keyword or early exit would have made things clearer.

Logging the world tree

One of the things that actually happened fairly early on in the world-state conversion was a n explosion of text.  You see, before the speculator didn't implement most of the player methods, including the output wrapper.  Now that they were being executed by an actual player, every possible history was being printed out (often multiple times, because I still had rate, judge, legality, and execute)  The solution was to store the notes in the state and print it out every time it checkpoints a successful move.

If I ever get around to making a way to print out the history, the saved logs will also make it easier to follow.

Retiring Prototype

Somewhere along the way, I realized that the program is pretty much implemented - It's just going to get slowly rewritten a few times over from now on.  My Prototype module, which allowed the program to keep running despite missing methods had outlived it's usefulness, as was removed from all classes, as it was hiding errors more often than anything.

ruby -w

I ran across a new trick - Ruby's warning flag.  Unfortunately all it caught were two uninitialized instance variables, so it's hardly a necessity.

<a href="http://oreilly.com/catalog/9780596516178/?CMP=OTC-KW7501011010&ATT=9780596516178">The Ruby Programming Language</a>

During the course of the weekend, I got two hits on a new ruby book, both of which appeared to have good answers to nuts and bolts questions about how Ruby works.  I figured this was good enough to justify buying the book, so I finally got the <a href="http://thisisindexed.com/">Indexed</a> book, and picked up a long overdue copy of the highly regarded The C Programming Language while I was at it.

Change of Tempo

Last year my pattern was to program during the weekend, and take care of everything else during the week.  So far this year, I've often had lots of interruptions during the weekend, which has often caused me to trade out and bleed the programming into the week.  When I get to the time of day Sunday where I should be wrapping up (and writing things like this), I'm just getting started.  This has been happening a fair bit lately, but I've also been feeling pretty good lately.  I'm thinking of switching to a pattern of coding a little every day, and taking care of everything else in what's left of the days off.  The main trick here is that without a clean iteration break after the weekend, I'll have to remember to write my experiences more as they happen.

-----

2009-01-29

Poisoning the Well

In my continuous quest to incorporate versioned state all the down, I've been looking with suspicion on the execute method.  It's what ultimately gets called to do a card or action.  It's also part of the language, in case, such as in 'use twice', one needs to do something without trying to discard it.  However, it's status as a primitive of sorts means it doesn't have have the speculation safety check that prevents illegal actions; only the chance that so far it's always been called inside another speculation has averted disaster.

Simply implementing this has far from desired results however, because it's been hiding a deeper problem.  I've discovered that my legality check only works for one level.  Illegal actions aren't performed, but they also aren't propagated in case of multi-step processes.  The speculation creates an exception barrier to later speculations.

My strategy so far has been to make the illegal state poisonous.  Right now I'm not committing an illegal speculation.  In the new scheme, I would always commit it where there would otherwise be a legality check.  The thing that will (or should) keep illegal actions from being performed is a combination of the choice process and a fitness function that always rates illegal actions lower than any legal action.  If an illegal state is ever committed to reality, the only thing to do is raise an language error informing the author that he needs a better fitness function for the AI or a 'pass' action that is always legal.

Actually, I'm a ninny.  I've introduced new mechanics, but they are still being used in old ways.  I've changed how things are supposed to work and kept the same mechanisms.  Every 'illegal state' originates in an exception.  What the speculation does it commute that into a boolean that can be examined later.  Previously, I'd been checking for legal states before performing things, but this hid errors.  Now I'm not checking that flag anymore, and I've written a bunch of code of propagate errors, most of it specs, refactoring, and debug support.  I could just let the exception keep on going to much the same effect.  Catching the errors only matters where the program will make some decision based upon it.  This is only the choice points now.

Did I Waste My Day?

Maybe.  Error propagation might come into play where all choices are illegal, when the best one got committed, it would set the illegal flag and propagate it up.  This might be useful for choice-within-choice scenarios.  On the other hand, I'm probably better off raising a "no legal choice" exception, which is really a better description of the problem.

A Little Less Than Random

I made one small tweak to the stopgap fitness function - add the number of changes to game state.  I was trying to get rid of needless discards, but it turns out that a discard touches as much game state as most actions (cards still move from hand to discard, plus some book-keeping information.)

2009-01-30

-----

Whats in a Name?

I've been making lots of references to the versioned store of world states.  I'm starting to think that I ought to call it Yggdrasil just so i have a good name for it.  My main reluctance to do this is lack of good names for the sub-concepts, some of which work quite well - Citizen in particular.  Well, that and renaming everything from nordic mythology would probably make it harder to understand.

I went ahead and renamed it Yggdrasil.  View could then become World, and ver_accessor and friends become ygg_accessor, but not much else.  I'm a little uneasy with the name Passport, but I don't have a better one at the moment.  Another small change was replacing descend/ascend, which were easy to confuse, with grow/prune.

I've also separated gsl and Yggdrasil into separate subdirectories, though still within the gsl project.  I'm debating wether to fully separate them, or leave it like that since they may continue to co-evolve.

Another name on the chopping block is Speculation,  It's a bit of a mouthful and is too reminiscent of specification, which is the testing framework.  I've replaced it with Future.

2009-02-20

--------

Settling The Score

I've replaced random choice with something less random.  If the game has a score method, that will be used to judge alternate game states.  It's not a perfect solution by any means - resource building may be more important early on, and some beginning and intermediate resources may not figure into the score at all.  The real trick will be figuring out a way to account for these factors without requiring the game author to set up a special AI section.  I might need some hook for that anyway, to allow setting up different play styles.

Credit Crisis

This is in but one step in pursuit of one particular feature:  Industrial Waste has an 'any time' action which allows a player to take a loan.  If I was just coding IW, this would be a simple hook on the pay-money routine.  However, I'm going for a general language of game rules.  The rules define it as an any time action.  More importantly, other games define more and varied kinds of free actions.

Unsettling the Score

Getting a real scoring method to rate futures in place was big piece of the puzzle - it makes it possible for a player to evaluate taking the loan (however badly)  Unfortunately, I've got a bit of cynical recursion.

My first attempt to hook up the any time actions was to put them in take_turn.  A player has the option of taking the normal turn, or taking it after each possible any time action.  Since a player might need to take a loan during things like an auction sub-game, this has to happen any time we iterate players.  Here's the catch: in order to choose one of those options the player has to rank them.  Ranking uses the score method if it's available.  The score method iterates each player to calculate his score - which brings us back to take_turn and choosing whether or not to take a loan first.  Please wait for the ride to come to a complete stop - when Ruby throws an exception because the stack got too big.

Now What?

I could move the free actions to the choose method.  Just extend the list of things we're choosing from with the free actions.  This won't work for IW because the place where I really need loans to work is the mandatory maintenance costs, where there is no choice involved.  And what if a free action has a choice?

I could have a different version of player iteration for non-game situations.  However, the natural way to describe calculating the score is with each_player, which is also the natural way to describe many in-game activities.  It shouldn't matter to the game author how I'm implementing free actions.

It might matter, however, when free actions are available.  I could force rule writers to explicitly say when free actions are allowed as a step in every process.  While this could be considered overhead, it's somewhat attractive because it forces people to think about when these things actually should be available.  In IW's case, the actual rules definition is any time, but getting it out of basic methods like each_player would certainly resolve the problem.

A Fatal Flaw

There is a fatal flaw with this, and with my whole system: I could make a separate routine that choose between 'take-a-loan' and 'do-nothing'  Unfortunately, this would always choose 'do-nothing' because it's an isolated event - the choice is made without considering what events come afterwards.  

The only obvious way to do this in Ruby would be to make the entire rest of the action a block passed to the any time action, which is a rather unnatural way of writing things, from a pure rules perspective.  If there were multiple opportunities during the course of an action, the indents would just keep on piling up.

2009-02-24

--------
